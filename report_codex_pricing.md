# Codexを活用したプライシングに関する一考察
（pricing-automation 実装・運用報告）

作成日: 2026-01-11
報告者: pricing-automation 実装責任者（博士）
提出先: 上席マネージャー

## 要旨
本報告は、養老保険の保険料算定と収益性検証を自動化する「pricing-automation」リポジトリを、実装者・管理者の立場から総括したものである。特に、Codex を活用した開発プロセスと、数理的な設計判断、実装上の論点、運用上の課題を体系的に整理した。リポジトリは、保険料計算（給付現価 A と年金現価 a）、キャッシュフロー生成、IRR/NBV 等の収益性指標算出、負荷率（alpha/beta/gamma）の最適化、および premium-to-maturity（PTM）比率のスイープ分析を実装しており、Excel のゴールデンファイルとの一致性検証を行うテスト群によって、検算可能性を担保している。

Codex の活用は、単なるコード生成ではなく、仕様の言語化、実装の分解、検証項目の設計、アルゴリズムの説明可能性の確保に寄与した。一方で、構成管理（YAMLスキーマと実装の乖離）、前提データの取り扱い、数理モデルの限界、AI支援に伴う再現性・説明責任の問題など、今後の改善課題も明確となった。本報告では、これらの成果と課題を、研究開発的観点および運用ガバナンスの観点から統合的に評価する。

## 1. 背景と目的
保険商品のプライシングは、保険数理・商品戦略・収益性検証の交点に位置し、前提（死亡率・利率・費用）を明示した上で、実務的に説明可能な形での検証が求められる。本リポジトリは、従来 Excel に依存していた作業フローを、Python により再現可能かつ拡張可能な形へ移行することを狙いとして構築された。

目的は以下の通りである。
- 養老保険における保険料計算および収益性検証の標準化と再現性確保
- 係数（alpha/beta/gamma）やPTM比率の探索を通じた感度分析と意思決定支援
- Excel に依存した属人的工程の削減と、テスト可能性の向上
- Codex を活用した迅速なプロトタイピングと、設計・検証を伴う実装管理

## 2. リポジトリ概観
ディレクトリ構成は概ね以下の通りであり、責務が明確に分離されている。

```
configs/    # 実行設定 YAML
data/       # 入力データ（死亡率・スポット・費用）
out/        # 出力（Excel/CSV/ログ）
scripts/    # 入力データ生成・抽出
src/pricing # 実装本体（計算・最適化・出力・CLI）
tests/      # テスト
```

主要モジュールの役割は以下の通りである。
- `src/pricing/endowment.py`: 養老保険の給付現価・純/総保険料計算
- `src/pricing/profit_test.py`: キャッシュフロー生成と IRR/NBV 等の収益性指標算出
- `src/pricing/optimize.py`: alpha/beta/gamma 係数の段階的探索と最適化
- `src/pricing/sweep_ptm.py`: PTM比率のスイープ評価
- `src/pricing/config.py`: YAML 設定の読み込みとデフォルト適用
- `src/pricing/outputs.py`: Excel/ログ出力の整形
- `src/pricing/cli.py`: CLI エントリポイント（run/optimize/sweep-ptm）
- `scripts/bootstrap_from_excel.py`: ゴールデン Excel から CSV 抽出
- `scripts/generate_virtual_company_data.py`: 仮想会社費用データ生成

依存ライブラリは `pyproject.toml` に整理されており、`pandas`・`numpy`・`openpyxl`・`pyyaml` が基盤となっている。テストは `pytest` を想定している。

## 3. Codex活用の作成過程と設計思考
本プロジェクトにおける Codex の役割は、「高速な実装補助」だけではなく、「設計判断を言語化し、検証可能なコードへ落とし込む支援」であった。以下は実際の活用方針である。

- 設計の分解: 収益性検証を「保険料計算」「準備金係数」「キャッシュフロー」「評価指標」へ分割することで、実装範囲を明確化した。
- 自動生成の統制: Codex が出力したコードは、必ずゴールデン Excel との一致検証（`tests/test_against_excel.py`）で裏付けを行った。
- 説明可能性の担保: 数式・用語のコメントや docstring により、目的・前提・単位系を明確化した。
- 検証ファースト: 実装の各段階で、単体テストやダミーデータによる検証を先に設計した。

Codex の活用は、仕様の揺らぎを助長する危険性もあるため、レビューと検証の仕組み（テスト・Excel比較）を強化する設計を採用した。特に、保険数理の領域では「言語生成の正しさ」と「数値的一致」が乖離し得るため、AI生成物の採用基準は「再現可能な計算結果を示すこと」に置いた。

## 4. モデル設計と計算ロジックの要点
### 4.1 保険料計算（`endowment.py`）
養老保険の純保険料計算は、死亡給付と満期給付を合算した給付現価 A と、払込期間に基づく年金現価 a を基礎に、

- `net_rate = A / a`
- `gross_rate = (net_rate + alpha / a + beta) / (1 - gamma)`

として総保険料率を算定する。ここで alpha/beta/gamma は費用負荷を表現する係数であり、`LoadingFunctionParams` によって年齢・性別・期間の感応度を線形関数として表現する。線形関数とした理由は、探索空間の解釈可能性と最適化計算量の抑制である。

### 4.2 生存確率・死亡率変換（`commutation.py`）
死亡率 CSV は年齢別に読み込み、性別ごとに `q_by_age` へ変換される。生存確率は `p_{x:t} = Π(1 - q)` で構築し、保険料計算・準備金計算の双方で再利用される。ここでは入力データの欠損に対して明示的に例外を出す設計とし、データ品質の問題を早期検出できるようにした。

### 4.3 収益性検証（`profit_test.py`）
収益性検証は、以下の順序でキャッシュフローを生成する。

1. 予定死亡率・実績死亡率・スポットカーブの読み込み
2. モデルポイントの展開（単数・複数に対応）
3. 準備金係数（tV/tW）と保有率・失効率系列の生成
4. 年次キャッシュフローの構築（保険料収入、死亡給付、解約返戻金、費用、準備金変動、運用収益）
5. IRR と NBV の算出

IRR は二分法で算出し、NPV がブリケットされない場合に明確な例外を投げる設計である。NBV は割引現在価値の合計として計算され、Excel の「収益性検証」シートとの対応関係が明示されている。

### 4.4 费用モデルの二系統
費用は以下のいずれかで扱う。
- `company` モード: `data/company_expense.csv` から獲得費・維持費・集金費を推定
- `loading` モード: alpha/beta/gamma を費用負荷として計上

この二系統は、実データの有無に応じた柔軟な運用を意図している。ただし、設定スキーマの不一致（`overhead_split` と `include_overhead_as` の名称の乖離）については課題として後述する。

## 5. 最適化とスイープ分析の設計
### 5.1 係数最適化（`optimize.py`）
最適化は、段階的な座標探索を採用する。主な設計意図は以下の通り。

- 探索対象を「ベース係数」「年齢・期間係数」「性別係数」の段階に分割する
- hard 制約（IRR、充足額、PTM上限、NBV）を満たすことを優先する
- soft 目標（IRRターゲット、PTMターゲット）をペナルティとして扱う
- L2 正則化で過度な係数値を抑制する
- `maximize_min_irr` モードにより、最小IRRの最大化を優先できる

最適化は `OptimizationSettings` により設定可能であり、`configs/trial-001.yaml` に初期的な利用例がある。実務上は、IRR を下限ではなく最大化指標として扱うことが多いため、`objective.mode = maximize_min_irr` を実装している。

### 5.2 PTMスイープ（`sweep_ptm.py`）
PTM比率を一定範囲でスイープし、IRR・NBV・loading surplus を評価する機能を提供する。これは、保険料水準の感度分析や、免除対象（制約を満たす r が見つからないモデルポイント）の特定に用いられる。

ここでは `loading_alpha_beta_gamma` の直接指定を前提としており、`loading_parameters`（関数係数）との接続は未実装である。これは仕様の一貫性における改善ポイントである。

## 6. データパイプラインと再現性
### 6.1 データ管理
`data/README.md` にある通り、実データは Git 管理対象から除外する前提で運用する。これにより、機密情報混入のリスクを軽減できる。代替として、仮想会社データ生成スクリプトと、Excel からのブートストラップ機能を提供している。

### 6.2 Excel からの抽出（`scripts/bootstrap_from_excel.py`）
ゴールデン Excel (`data/golden/養老保険_収益性_RORC.xlsx`) から死亡率・スポットカーブを抽出する。抽出ロジックはラベルベースの探索であり、シート構造に依存するため、Excel側の構造変更時には注意が必要である。例外処理により、欠損時の明確なエラー通知を行う設計である。

### 6.3 仮想会社データ生成（`virtual_company.py`）
実データが不足する局面に備え、費用総額を再現性ある乱数で生成する。`VirtualCompanySpec` により、規模・成長率・単価・ノイズ幅を明示的に設定できる。目的は「妥当性の主張」ではなく「再現性と前提の透明化」であり、検証用データとしての役割を担う。

## 7. テストと検証戦略
テスト設計は「実務検算可能性」を最重要視した。主要なテストは以下の通りである。

- `tests/test_against_excel.py`: Excel ゴールデンファイルと保険料・IRR・NBVを一致検証
- `tests/test_sweep_ptm.py`: スイープ結果の行数・NaN除去・計算整合性を検証
- `tests/test_optimize_exemption.py`: 免除設定がログに正しく反映されることを検証
- `tests/test_watch_model_points.py`: 監視モデルポイントが制約判定から除外されることを検証

Excel に依存するテストは、ファイルが無い場合に skip する設計であり、CI 環境においても無用な失敗を回避できる。これは、AI生成コードの再現性評価において重要な実装判断であった。

## 8. 実装上の課題と論点
現状のリポジトリは動作可能である一方、運用面で以下の課題が顕在化している。

### 8.1 設定スキーマと実装の乖離
`configs/trial-001.yaml` において、`profit_test.expense_model` のキーが `include_overhead_as` となっているが、実装側は `overhead_split` を参照している。結果として、意図された配賦率が反映されず、デフォルト値が適用される可能性がある。これは実務上の解釈リスクであり、設定スキーマの統一または警告機構が必要である。

### 8.2 前提パラメータの重複
`pricing.lapse.annual_rate` が設定ファイルに存在する一方で、実装は `profit_test.lapse_rate` のみを使用している。前提の二重化は、ユーザが誤った値を参照するリスクを生むため、入力構造の整理が必要である。

### 8.3 文字化け・エンコーディング問題
README や一部のソースコメントに文字化けが見られる。コード実行には影響しないが、設計意図の共有やレビュー効率に影響するため、UTF-8統一による整備が望ましい。

### 8.4 モデル前提の限定性
現行実装は養老保険に限定され、利率はフラット、失効率は定数といった簡素化前提を置いている。将来的に他商品や市場環境に対応するためには、前提の拡張設計（利率曲線の導入、年齢別失効率など）が必要である。

### 8.5 最適化の探索効率
座標探索は理解しやすい一方で、探索次元の増加に伴う計算量が増大する。実務でモデルポイント数が増えた場合、探索効率を改善する必要がある。具体的には、近似勾配を用いた探索や、並列化、あるいはベイズ最適化の導入が候補となる。

## 9. Codex活用の評価とガバナンス論点
Codex は高い生産性を提供するが、以下の観点で明確なガバナンスが必要である。

- 検証責任: AI生成コードは「正しいように見える」ことが多く、数理モデルの誤実装が潜在する。ゴールデン Excel 比較を必須としたことは、モデルリスク低減に有効であった。
- 設計透明性: Codex を介した設計では、仕様の背景がブラックボックス化しやすい。docstring と単位表記の明確化により、設計意図を可視化した。
- 変更履歴の統制: AI支援による改変は差分が大きくなりやすい。小さな単位でのコミット運用とレビュー前提の作業分割が重要である。

結論として、Codex は「人間の意思決定を補助する加速装置」であり、最終責任は実装者が持つべきである。この構造を前提に、検証可能性と説明可能性を強化する体制が必要である。

## 10. 今後の改善提案
本報告時点での改善提案は以下の通りである。

- 設定スキーマの統一: YAML スキーマを定義し、未使用キーの警告やバリデーションを導入する
- `loading_parameters` と `loading_alpha_beta_gamma` の一本化: スイープ機能で関数係数を扱えるように統合する
- 失効率・利率の拡張: 年齢別/期間別の変動モデルを導入する
- 出力の標準化: ログ形式・Excel形式のテンプレート化を行い、外部レポート出力と接続する
- データ品質管理: CSV に対するスキーマ検証と異常値検出を追加する
- 最適化アルゴリズムの高度化: グリッド探索の並列化または確率的探索の導入

## 11. まとめ（上司への報告）
本リポジトリは、養老保険のプライシング業務を「再現可能な数理エンジン」として実装した点に意義がある。Codex を活用することで開発速度は大幅に向上したが、同時に検証・統制の重要性が増した。現行のテスト群は Excel 検算という強い基準を提供しており、AI活用下でも信頼性を担保できる構造になっている。

一方で、設定スキーマの不一致や前提の二重化、文字化けなど、運用における実務リスクが顕在化している。これらは技術的負債として早期に解消することが望ましい。次フェーズでは、商品拡張・利率/失効モデルの高度化・最適化アルゴリズムの改善を優先し、実務適用可能性をさらに高める計画である。

以上、研究開発の成果と課題を併せて報告する。必要であれば、次回は「商品拡張の具体的設計案」と「データガバナンス方針」を別途提案する。

---

### 付録A: 本リポジトリの主要ファイル対応表
- `src/pricing/cli.py`: CLI 入口、run/optimize/sweep を統合
- `src/pricing/endowment.py`: 養老保険の保険料計算
- `src/pricing/profit_test.py`: キャッシュフローとIRR/NBV算出
- `src/pricing/optimize.py`: 係数探索と制約評価
- `src/pricing/sweep_ptm.py`: PTMスイープ分析
- `src/pricing/config.py`: 設定読み込み・デフォルト適用
- `src/pricing/outputs.py`: Excel/ログ出力
- `scripts/bootstrap_from_excel.py`: ゴールデンExcel抽出
- `scripts/generate_virtual_company_data.py`: 仮想会社費用データ生成

### 付録B: CLI 実行例
```powershell
$env:PYTHONPATH = "src"
python -m pricing.cli run configs/trial-001.yaml
python -m pricing.cli optimize configs/trial-001.yaml
python -m pricing.cli sweep-ptm configs/trial-001.yaml --model-point male_age30_term35 --start 1.0 --end 1.05 --step 0.01
```

## 追補1: 数理設計の詳細とExcel整合性
本実装は、Excel で参照していた数理定義を可能な限りコード上に明示し、数式の可視化を重視した。具体的には、死亡給付現価を「期中死亡（t+0.5）」として割引する定義を採用し、Excel で一般的に用いられる中間期死亡近似を踏襲している。準備金係数 tV と解約返戻金係数 tW についても、10年逓減の解約控除（`(10 - min(t,10))/10`）を明示し、解約返戻金の算定が Excel と整合するように設計した。

フォワードレートはスポットレートから導出し、`forward_t = (1+spot_{t+1})^(t+1) / (1+spot_t)^t - 1` の形で算定する。これにより、キャッシュフロー計算では「期間ごとの資産運用利回り」を再現し、単純なフラット利率では見えない年次ごとの収益性変動を捉えられる。割引係数はスポットレートを用いて `spot_df = (1 + spot_rate)^-(t+1)` としており、NBV（新契約価値）の算定においても Excel の算定ロジックと一致する。

IRR は二分法で計算する設計とし、NPV の符号が変化しない場合に例外を投げる。これは AI の生成コードによく見られる「収束条件の曖昧さ」を避けるための判断であり、実務上の異常値検知にも資する。必要に応じて最大反復回数や許容誤差を変更できる設計にしているが、現行値で Excel との差分が十分小さいことを確認済みである。

## 追補2: 実装プロセスと意思決定（Codex協働ログの要約）
実装は、設計 → 実装 → 検証 → 改訂の反復で進めた。Codex には、計算式の解釈やデータ構造の設計、テストケースの作成補助を依頼したが、最終決定は人間側で行う運用を徹底した。特に重要だった意思決定は以下の通りである。

- 仕様の粒度調整: いきなり多商品対応に広げず、養老保険で単一ラインを作り切る方針を採用した。これは検証可能性を優先した判断である。
- 既存 Excel との一致性: Codex が提案する数式が、Excel の実装と一致しているかを逐一検算した。数式の「見た目の正しさ」ではなく、「一致性」を採用基準にした。
- 例外設計: 欠損データや不正値に対する例外を厚めに定義し、運用時の誤入力を早期に顕在化させる設計を採用した。
- 設定の後方互換: 旧設定キー（constraints/expense_sufficiency）への参照を残し、既存 YAML の移行コストを下げる配慮を行った。

Codex は生成コードのベースとして有効であったが、条件分岐や境界値処理においては意図が誤解される場面もあったため、テストとレビューの併用は必須であるという結論に至っている。

## 追補3: 研究的論点の整理
研究開発的な視点からは、次の論点が重要である。

1) 同定可能性の問題
loading 係数（alpha/beta/gamma）をモデルポイントごとに線形関数で表現しているが、IRR・NBV・PTM など複数指標を同時に満たす係数は必ずしも一意ではない。これは同定可能性の問題であり、正則化や目的関数の設計が結果に強く影響する。

2) 目的関数と制約の設計
`maximize_min_irr` モードは「最小IRRの最大化」という公平性志向の設計であるが、NBV の最大化とはトレードオフ関係にある。ビジネス上の目的をどの指標で代表させるかは、明示的に議論されるべき論点である。

3) PTM 比率の運用意義
PTM は保険料総額と満期保険金の比率であり、顧客説明の観点でも重要だが、IRR の改善と相反する場合がある。PTM を hard 制約に置くのか、soft 制約に置くのかは商品戦略に依存する。

4) データ前提の頑健性
死亡率や費用前提の微小な変化が IRR/NBV に与える影響は大きく、感度分析が必須である。スイープ機能はこのための基礎機能として設計したが、将来的にはシナリオ分析やストレステストを組み込むことが望ましい。

## 追補4: 運用・監査の観点
実務導入を見据えた場合、監査対応と説明責任の整備が不可欠である。現行設計における運用上の強みと弱点は以下の通りである。

- 強み: YAML による前提管理、ログ出力、Excel出力の整合性テスト、再現性のある仮想データ生成
- 弱点: 設定スキーマの明確な定義が未整備、入力CSVのスキーマ検証が未実装、実データの管理プロトコルが未標準化

短期的には「設定バリデーション」「入力データ検証」「実行ログのバージョン管理」を導入すべきである。中期的には、実行環境の固定化（Docker化）と、監査証跡としての「計算バージョン固定」の仕組みを整備する必要がある。

以上、追補として数理整合性・開発プロセス・研究論点・運用監査の観点を補足した。

## 追補5: 用語と単位の整理
本報告で扱った主要用語と単位を簡潔に整理しておく。実務での説明責任を果たすため、単位の混在を避けることが重要である。特に loading 係数は「保険料倍率」ではなく、「保険金額当たりの費用係数」である点を明示する必要がある。

- IRR: 年率（内部収益率）
- NBV: 円（割引現在価値の合計）
- alpha/beta: 保険金額当たりの費用係数（円換算に影響）
- gamma: 料率の比率項（無次元）
- PTM: 総保険料 / 満期保険金（比率）

以上の整理を踏まえ、設定・ログ・Excel 出力で同一の単位表記を維持することが、監査・レビュー双方の信頼性確保に直結する。
